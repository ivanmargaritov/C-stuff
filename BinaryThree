#include <iostream>
#include <cassert>
#include <string.h>

using namespace std;

template <class T>
using mapFn = T(*) (const T&);

template <class T>
struct Node
{
	T data;
	Node<T>* left;
	Node<T>* right;

	Node(const T& data, Node<T>* left, Node<T>* right)
	{
		this->data = data;
		this->left = left;
		this->right = right;
	}
	Node()
	{
		this->left = nullptr;
		this->right = nullptr;
	}
};

template <class T>
class BTree
{
private:
	Node<T>* root;
	void simplePrint(Node<T>* subTreeRoot) const;
	bool add(const T& data, const char* trace, Node<T>* & subTreeRoot);
	void deleteAll(Node<T>* subTreeRoot);
	bool member(const T& data, Node<T>* subTreeRoot) const;
	void map(mapFn<T> f, Node<T>* subTreeRoot);
	int count(Node<T>* subTreeRoot);
	int countEvens(Node<T>* subTreeRoot);
	int searchCount(mapFn<T> f, Node<T>* subTreeRoot);
	int height(Node<T>* subTreeRoot);
	int countLeaves(Node<T>* subTreeRoot);
	T& maxLeaf(T max, Node<T>* subTreeRoot);
public:
	BTree();
	void simplePrint() const;
	BTree<T>& add(const T& data, const char* trace);
	~BTree();
	bool member(const T& data) const;
	void map(mapFn<T> f);
	int count();
	int countEvens();
	int searchCount(mapFn<T> f);
	int height();
	int countLeaves();
	T& maxLeaf();
};

template<class T>
BTree<T>::BTree()
{
	this->root = nullptr;
}

template <class T>
void BTree<T>::simplePrint(Node<T>* subTreeRoot) const
{
	if (subTreeRoot == nullptr)
	{
		return;
	}
	cout << subTreeRoot->data << " ";
	simplePrint(subTreeRoot->left);
	simplePrint(subTreeRoot->right);
}

template <class T>
void BTree<T>::simplePrint() const
{
	simplePrint(root);
}

template <class T>
bool BTree<T>::add(const T& x, const char* trace, Node<T>* & subTreeRoot)
{
	if (subTreeRoot == nullptr)
	{
		assert(strlen(trace) == 0);
		subTreeRoot = new Node<T>(x, nullptr, nullptr);
		return true;
	}
	assert(strlen(trace) > 0);
	if (trace[0] == 'L')
	{
		return add(x, trace + 1, subTreeRoot->left);
	}
	assert(trace[0] == 'R');
	return add(x, trace + 1, subTreeRoot->right);
	return true;
}

template <class T>
BTree<T>& BTree<T>::add(const T& x, const char* trace)
{
	add(x, trace, root);
	return *this;
}

template <class T>
void BTree<T>::deleteAll(Node<T>* subTreeRoot)
{
	if (subTreeRoot == nullptr)
	{
		return;
	}
	delete subTreeRoot;
	deleteAll(subTreeRoot->left);
	deleteAll(subTreeRoot->right);
}

template <class T>
BTree<T>::~BTree()
{
	deleteAll(root);
}

template <class T>
bool BTree<T>::member(const T& x, Node<T>* subTreeRoot) const
{
	if (subTreeRoot == nullptr)
	{
		return false;
	}
	return subTreeRoot->data == x || member(x, subTreeRoot->left) || member(x, subTreeRoot->right);
}

template <class T>
bool BTree<T>::member(const T& x) const
{
	return member(x, root);
}

template <class T>
void BTree<T>::map(mapFn<T> f, Node<T>* subTreeRoot)
{
	if (subTreeRoot == nullptr)
	{
		return;
	}
	subTreeRoot->data = f(subTreeRoot->data);
	map(f, subTreeRoot->left);
	map(f, subTreeRoot->right);
}

template <class T>
void BTree<T>::map(mapFn<T> f)
{
	map(f, root);
}

int plusOne(const int &i)
{
	return i + 1;
}

template <class T>
int BTree<T>::count(Node<T>* subTreeRoot)
{
	if (subTreeRoot == nullptr)
	{
		return 0;
	}
	return 1 + count(subTreeRoot->left) + count(subTreeRoot->right);

}

template <class T>
int BTree<T>::count()
{
	return count(root);
}

template <class T>
int BTree<T>::countEvens(Node<T>* subTreeRoot)
{
	if (subTreeRoot == nullptr)
	{
		return 0;
	}
	int count = 0;
	if (subTreeRoot->data % 2 == 0) {
		count++;
	}

	return count + countEvens(subTreeRoot->left) + countEvens(subTreeRoot->right);
}

template <class T>
int BTree<T>::countEvens()
{
	return countEvens(root);
}

template <class T>
int BTree<T>::searchCount(mapFn<T> f, Node<T>* subTreeRoot)
{
	if (subTreeRoot == nullptr)
	{
		return 0;
	}
	if (f(subTreeRoot->data)) {
		return 1 + searchCount(f, subTreeRoot->left) + searchCount(f, subTreeRoot->right);
	}
	else
	{
		return searchCount(f, subTreeRoot->left) + searchCount(f, subTreeRoot->right);
	}
}

template <class T>
int BTree<T>::searchCount(mapFn<T> f)
{
	return searchCount(f, root);
}

bool oddNumber(const int& num)
{
	return (num % 2 == 1) ? 1 : 0;
}

int max(int a, int b) 
{
	return (a > b) ? a : b;
}

template <class T>
int BTree<T>::height(Node<T>* subTreeRoot)
{
	if (subTreeRoot == nullptr) {
		return 0;
	}
	return max(height(subTreeRoot->left), height(subTreeRoot->right)) + 1;
}

template <class T>
int BTree<T>::height()
{
	return height(root);
}

template <class T>
int BTree<T>::countLeaves(Node<T>* subTreeRoot)
{
	if (subTreeRoot == nullptr)
	{
		return 0;
	}
	if (subTreeRoot->left == nullptr&&subTreeRoot->right == nullptr)
	{
		return 1;
	}
	else return countLeaves(subTreeRoot->left) + countLeaves(subTreeRoot->right);
}

template <class T>
int BTree<T>::countLeaves()
{
	return countLeaves(root);
}

template <class T>
T& BTree<T>::maxLeaf(T max, Node<T>* subTreeRoot)
{
	if (subTreeRoot == nullptr)
	{
		return max;
	}
	if (subTreeRoot->left == nullptr&&subTreeRoot->right == nullptr)
	{
		if (max > subTreeRoot->data)
		{
			return max;
		}
		else
		{
			return subTreeRoot->data;
		}
	}
	if (maxLeaf(max, subTreeRoot->left) > maxLeaf(max, subTreeRoot->right))
	{
		return maxLeaf(max, subTreeRoot->left);
	}
	else
	{
		return maxLeaf(max, subTreeRoot -> right);
	}
}

template <class T>
T& BTree<T>::maxLeaf()
{
	return maxLeaf(0, root);
}

int main()
{
	BTree<int> t;
	t.add(2, "");
	t.add(3, "L");
	t.add(342, "R");
	t.add(9, "LL");
	t.add(26, "LR");
	t.add(18, "RL");
	t.add(1, "RR");
	//t.add(9, "LL");
	//t.add(12, "LLR");
	//t.add(14, "LRL");
	t.add(16, "LRR");
	

	t.simplePrint();
	cout << endl << "-----------------" << endl;
	cout <<"IS 2 IN THE TREE?   "<< t.member(2) << endl;
	cout <<"IS 43 IS THE TREE?   "<< t.member(43) << endl;
	t.map(plusOne);
	cout << "PlusOne function applied: ";
	t.simplePrint();
	cout << endl;
	cout <<"COUNT: "<< t.count() << endl;
	cout << "COUNT EVENS: "<<t.countEvens() << endl;

	//cout << t.searchCount(dividesByFive);
	cout <<"HEIGHT: "<< t.height() << endl;
	cout << "LEAVES: " << t.countLeaves() << endl;
	cout << "MAX LEAF: " << t.maxLeaf() << endl;
	system("pause");
	return 0;
}
